#!/usr/bin/perl
use strict ; use warnings ; 
use feature 'say' ;
use File::Find ; 
use Filesys::DiskUsage qw [ du ] ; 
use Getopt::Std ; getopts ',:b:BG:' , \my %o ; 
use List::Util qw[ max sum0 ] ;
use POSIX qw [ strftime ] ; 
use Term::ANSIColor qw[ :constants ] ; $Term::ANSIColor::AUTORESET = 1 ;
binmode STDOUT , ':utf8' ;
$o{b} //= 512 ;

sub d3 ($) { $_[0] =~ s/(?<=\d)(?=(\d\d\d)+($|\D))/,/gr } ; # 数を3桁区切りに変換する。
if ( 0 eq ( $o{','} // '') ) { * d3 = sub ($) { $_[0] } } ; # -,0が指定されたら3桁区切りにしない。

my $datetime = strftime ( '%Y-%m-%d(%a) %H:%M:%S %Z(%z)', localtime () ) ; 
& change_dir ( $ARGV[0] // '.' ) ; 
& getFiles ( \my @files , \my @visible ) ; # visibeは見えるファイル、つまり、ドットファイル以外のファイルを意味する。
#if ( $o{B} ) { 1 }
& prepCommands ( \@files , \@visible , $datetime, my $msg , my $change , my $cmd1 , my $cmd2 ) ; # change はファイルの変更個数, 
do { say $msg ; exit } unless exists $o{G} ; # -Gの指定があればさらに続く。
if ( $o{G} =~ /0/ ) { say "$cmd1\n$cmd2" } ; # -Gに0があれば、コマンド文を表示
if ( $o{G} =~ /1/ ) { & againCheck ( $change ) and exit } ; # -G に1があれば、もしも前のコミットでこのコマンドでコミット済みなら終了。
if ( $o{G} =~ /[12]/ ) { do { my $out2 = qx[$cmd2] ; binmode STDOUT , ':raw' ; say "-- ->", BOLD $out2 //'' } } ; # コミット実行! 
exit ; 

sub change_dir ( $ ) {
  my $pwd =  qx[ cd $_[0] && pwd ] =~ s/\n$//r ; #  Perlのchdirはbashのようなチルダ展開が出来ない。
  die BRIGHT_RED BOLD qq[Failed: "cd $_[0]"] if $? ;
  chdir $pwd or die qq [Failed: "chdir $pwd"] ; # 
}

sub getFiles ( $$ ) { 
  my $c2 = do { use File::Spec ; File::Spec -> catfile ( '' , '.' ) } ; # ディレクトリ階層の区切りの直後にドットがあるパターン
  @{ $_[0] } = split/\n/ , qx [ find . ] , 0 ;
  @{ $_[1] } = grep { ! m/\Q$c2\E/ } @{ $_[0] } ;
}

sub sumdu (@) { sum0 map { my @s = stat $_ ; max ( $s[7] , $o{b} * $s[12] ) } @_ } 

sub prepCommands ( $$$ $$$$ ) { 
  my ($b1,$b2) = map { sumdu ( @{ $_ [ $_ ] } ) } 0 .. 1 ; # バイト単位の数値なのでbを変数名に用いた。
  my ($l1,$l2) = map { scalar @{ $_ [ $_ ] } } 0 .. 1 ; # 配列の長さ l 
  $_[3] = sprintf "du: %s / %s = %0.3f", d3 $b1, d3 $b2 , $b1 / $b2 ;
  $_[3] .= sprintf "  obj: %s / %s = %0.2f  -- %s", d3 $l1 , d3 $l2 , $l1 / $l2 , $_[2] ;
  $_[5] = qq[ git diff --raw HEAD~..HEAD | wc -l # -- -> ] ; 
  $_[4] = (`$_[5]` =~ s/\n$//sr) ;
  $_[5] .= BOLD $_[4]  ;# 何個のファイルが HEADとその前の間で変更があったか。
  $_[6] = qq[ git commit --allow-empty -m '$_[3]' ] ; # --amend 
}

sub againCheck ($) {
  if ( $_[0] eq 0 ) { # さらに確かさを高めるために、計2個の条件で調べる。
    my $p1 = qr | .* [0-9] .*/.* [0-9] .*=.* [0-9] .* |x ; # <-- 少し雑な条件かも。しかし、きちんと書くと、バグの元になりやすい。
    my $pattern = qr| du: $p1 obj: $p1 -- .*\d{4}-\d{2}-\d{2} .* \d{2}:\d{2}:\d{2} |x ; # 
    return 1 if qx [ git log -n1 --oneline ] =~ m/$pattern/s ;
  } ; 
}

#   2022-03-01 thu ; Toshiyuki Shimono 下野寿之 (統計数理研究所 特任研究員)

## ヘルプの扱い
sub VERSION_MESSAGE {}
sub HELP_MESSAGE {
  use FindBin qw[ $Script ] ; 
  $ARGV[1] //= '' ;
  open my $FH , '<' , $0 ;
  while(<$FH>){
    s/\$0/$Script/g ;
    print $_ if s/^=head1// .. s/^=cut// and $ARGV[1] =~ /^o(p(t(i(o(ns?)?)?)?)?)?$/i ? m/^\s+\-/ : 1;
  }
  close $FH ;
  exit 0 ;
}

=encoding utf8

=head1 

  $0 dirname
  
 機能: 

   指定したフォルダに対して、ディスク使用量とそのフォルダ内で辿れるファイルの
  サイズのそれぞれ合計（共にバイト単位）などを標準出力に出力する。
  コマンドオプションにより、その出力をコミットメッセージにした Git の
    コミットに残すこともできる。

 オプション: 

    -, 0 : 千進法の3桁区切りのコンマを打たない。
    -b 512 : 各ファイルの占有するブロックサイズを取得して、それを何倍にすることで占有サイズと見なすかの、倍率。
    -G N: Gitのコミットのメッセージ(N=0,1,2) 以下を参照せよ。     
     -G 0 : 単に gitのコマンド文を出力する。そのgit文は、--allow-empty を使う。
     -G 1 : HEAD~とHEADの間の変更が、このプログラムで実行されてる可能性が高い場合は、そのgit文は実行しないようにする。
     -G 2 : その gitのコマンド文を実行する。(cronで実行すると、どんどんコミットが増えるので、やらない方が良い。) 
    -G 01 や -G02 など、0と1と2の複数を使ったオプション指定の仕方もできる。


 作成した目的: 
  
  データファイルを蓄えていくＧｉｔのレポジトリの、ディスク占有サイズのバイト数を、
  ワークツリー内の指定フォルダー内のファイルサイズの合計バイト数、および、
  その合計値に対する占有サイズの倍率と共に記録する。
  このことで、必要なディスクサイズの成長を見積もる。

　開発メモ: 
    * cronによる実行で、似たGitのコメントが多数作られないように、空コミットと直前コミット文の正規表現による条件チェックをしている。

=cut